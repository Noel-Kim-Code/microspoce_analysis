import sys
import cv2
import numpy as np
import time
import os
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                             QPushButton, QLabel, QFileDialog, QInputDialog, 
                             QMessageBox, QGroupBox, QRubberBand, QCheckBox) # QCheckBox 추가
# [핵심 1] PyQt 한글 폰트를 위해 QFont 임포트
from PyQt5.QtGui import QImage, QPixmap, QPainter, QPen, QFont 
from PyQt5.QtCore import QThread, pyqtSignal, Qt, QSize, QRect, QPoint
# [핵심 2] OpenCV 한글 처리를 위한 PIL(Pillow) 라이브러리 임포트
try:
    from PIL import Image, ImageDraw, ImageFont
except ImportError:
    print("오류: Pillow 라이브러리가 필요합니다. 'pip install Pillow'로 설치해주세요.")
    sys.exit()


# --- [핵심 2] 한글 폰트 경로 설정 ---
# [고객님 설정 유지] "HMKMRHD.TTF"
DEFAULT_FONT_PATH = "HMKMRHD.TTF"

def get_korean_font(size=20):
    """시스템 경로에서 한글 폰트(TTF)를 로드합니다. (PIL용)"""
    font_path = DEFAULT_FONT_PATH
    
    # [대체 경로 탐색]
    if not os.path.exists(font_path):
        print(f"경고: 지정된 폰트 '{font_path}'를 찾을 수 없습니다. 대체 경로 탐색을 시작합니다.")
        if sys.platform == "win32":
            font_path = "C:/Windows/Fonts/malgun.ttf"
            if not os.path.exists(font_path):
                 font_path = "C:/Windows/Fonts/gulim.ttc" # 굴림 (대체)
        elif sys.platform == "darwin": # macOS
            font_path = "/System/Library/Fonts/Supplemental/AppleSDGothicNeo.ttf"
        elif sys.platform == "linux":
            # 흔한 리눅스 경로 (다를 수 있음)
            font_path = "/usr/share/fonts/truetype/nanum/NanumGothicBold.ttf"
            if not os.path.exists(font_path):
                font_path = "/usr/share/fonts/truetype/nanum/NanumGothic.ttf"
                if not os.path.exists(font_path):
                    font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf" # 한글 안될 수 있음
        
    try:
        # 폰트 로드 시도
        print(f"PIL 폰트 로드 시도: {font_path}")
        return ImageFont.truetype(font_path, size)
    except IOError:
        print(f"경고: 한글 폰트 '{font_path}'를 찾을 수 없습니다. PIL 기본 폰트를 사용합니다.")
        # Pillow 기본 폰트 (한글 깨짐)
        try:
            return ImageFont.load_default()
        except Exception:
            print("PIL 기본 폰트 로드도 실패했습니다.")
            return None

# 상수: GUI에 표시될 영상의 기본 크기
DISPLAY_WIDTH = 800
DISPLAY_HEIGHT = 600

class VideoThread(QThread):
    """
    OpenCV 카메라 처리를 담당하는 백그라운드 스레드
    """
    change_pixmap_signal = pyqtSignal(np.ndarray)
    camera_started_signal = pyqtSignal(int, int) 
    brightness_update_signal = pyqtSignal(int) # 밝기 값 GUI 업데이트용 신호

    def __init__(self, camera_index=0):
        super().__init__()
        self.camera_index = camera_index
        self._running = True
        self._paused = False
        
        self._classify_mode = 'none' # 'none', 'mono_defect', 'color_part'
        
        self.view_rect = None 
        self.original_width = 0
        self.original_height = 0
        
        # [수정] 소프트웨어 밝기 제어
        self._brightness = 0
        self._brightness_delta = 0
        
        # --- [신규] 영상 필터 플래그 ---
        self._apply_wb = False      # 화이트 밸런스 (노란기 제거)
        self._apply_denoise = False # 노이즈 제거
        self._apply_sharpen = False # 선명하게
        
        self.kernel_sharpen = np.array([[-1,-1,-1],
                                        [-1, 9,-1],
                                        [-1,-1,-1]])
        
        # --- [신규] 일시정지 버그 수정을 위한 마지막 프레임 저장 ---
        self.last_good_frame = None
        
        # PIL 폰트 객체 미리 로드
        self.font_large = get_korean_font(size=24)
        self.font_small = get_korean_font(size=16)

    def run(self):
        """스레드 실행: 카메라 캡쳐 및 프레임 처리 루프"""
        cap = cv2.VideoCapture(self.camera_index)
        
        if not cap.isOpened():
            print(f"Error: Camera index {self.camera_index}를 열 수 없습니다.")
            return

        self.original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        if self.view_rect is None:
            self.view_rect = (0, 0, self.original_width, self.original_height)
        
        print(f"카메라 원본 해상도: {self.original_width}x{self.original_height}")
        self.camera_started_signal.emit(self.original_width, self.original_height)

        while self._running:
            # [수정] 일시정지 상태가 아닐 때만 새 프레임을 읽음
            if not self._paused:
                ret, original_frame = cap.read() 
                if ret:
                    # 마지막으로 성공한 프레임을 저장
                    self.last_good_frame = original_frame.copy()
            
            # [수정] 일시정지 여부와 관계없이, 마지막 프레임이 존재하면 처리를 계속함
            if self.last_good_frame is not None:
                # 마지막 프레임의 복사본으로 모든 처리를 시작
                current_frame = self.last_good_frame.copy()

                # --- [1] 소프트웨어 밝기 조절 로직 ---
                if self._brightness_delta != 0:
                    self._brightness += (self._brightness_delta * 10)
                    self._brightness = max(-100, min(100, self._brightness))
                    print(f"소프트웨어 밝기 변경: {self._brightness}")
                    self._brightness_delta = 0
                    self.brightness_update_signal.emit(self._brightness)
                
                if self._brightness != 0:
                    adjusted_frame = cv2.convertScaleAbs(current_frame, alpha=1.0, beta=self._brightness)
                else:
                    adjusted_frame = current_frame
                
                # --- [신규] 영상 필터 적용 ---
                if self._apply_wb:
                    adjusted_frame = self.correct_white_balance(adjusted_frame)
                if self._apply_denoise:
                    adjusted_frame = cv2.medianBlur(adjusted_frame, 5) # ksize=5
                if self._apply_sharpen:
                    adjusted_frame = cv2.filter2D(adjusted_frame, -1, self.kernel_sharpen)

                # --- [2] 줌(Crop) 로직 ---
                try:
                    x, y, w, h = self.view_rect
                    x, y, w, h = int(x), int(y), int(w), int(h)
                    cv_img = adjusted_frame[y:y + h, x:x + w]
                except Exception as e:
                    print(f"Crop Error: {e}, view_rect: {self.view_rect}")
                    cv_img = adjusted_frame

                # --- [3] 리사이즈 ---
                display_frame = cv2.resize(cv_img, (DISPLAY_WIDTH, DISPLAY_HEIGHT), 
                                           interpolation=cv2.INTER_LINEAR)
                
                # --- [4] 결함 분석 ---
                if self._classify_mode == 'mono_defect':
                    display_frame = self.run_defect_detection_mono(display_frame)
                elif self._classify_mode == 'color_part':
                    display_frame = self.run_defect_detection_color(display_frame)

                # --- [5] GUI 전송 ---
                self.change_pixmap_signal.emit(display_frame.copy())
            
            time.sleep(0.01)

        cap.release()

    def stop(self):
        self._running = False
        self.wait()

    def toggle_pause(self):
        self._paused = not self._paused
        return self._paused
        
    def increase_brightness(self):
        self._brightness_delta += 1

    def decrease_brightness(self):
        self._brightness_delta -= 1
    
    def set_view_rect(self, rect):
        self.view_rect = rect

    def set_classify_mode(self, mode):
        self._classify_mode = mode
            
    def set_white_balance(self, state):
        self._apply_wb = state
    
    def set_denoise(self, state):
        self._apply_denoise = state
        
    def set_sharpen(self, state):
        self._apply_sharpen = state

    def correct_white_balance(self, frame):
        try:
            avg_b = np.mean(frame[:, :, 0])
            avg_g = np.mean(frame[:, :, 1])
            avg_r = np.mean(frame[:, :, 2])
            avg_all = (avg_b + avg_g + avg_r) / 3
            scale_b = avg_all / avg_b
            scale_g = avg_all / avg_g
            scale_r = avg_all / avg_r
            
            balanced_frame = frame.copy()
            balanced_frame[:, :, 0] = np.clip(frame[:, :, 0] * scale_b, 0, 255).astype(np.uint8)
            balanced_frame[:, :, 1] = np.clip(frame[:, :, 1] * scale_g, 0, 255).astype(np.uint8)
            balanced_frame[:, :, 2] = np.clip(frame[:, :, 2] * scale_r, 0, 255).astype(np.uint8)
            
            return balanced_frame
        except Exception as e:
            print(f"White Balance Error: {e}")
            return frame
            
    # --- [검사 로직 1] 흑백(SEM) 이미지용 (흑백 뷰 + CLAHE 분석) ---
    def run_defect_detection_mono(self, frame):
        """ 
        [흑백 전용] OpenCV 임계값 및 컨투어 분석 기반 결함 검출
        """
        
        DEFECT_THRESHOLD = 50 
        MIN_AREA = 20
        CIRCULARITY_THRESHOLD = 0.6 
        
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        gray_analyzed = clahe.apply(gray)
        frame_to_display = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
        
        # [수정] gray -> gray_analyzed (극대화된 이미지로 분석)
        _, defect_mask = cv2.threshold(gray_analyzed, DEFECT_THRESHOLD, 255, cv2.THRESH_BINARY_INV)
        
        kernel = np.ones((3, 3), np.uint8)
        mask_opened = cv2.morphologyEx(defect_mask, cv2.MORPH_OPEN, kernel, iterations=1)
        
        contours, _ = cv2.findContours(mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        void_count = 0
        crack_count = 0
        
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > MIN_AREA:
                x, y, w, h = cv2.boundingRect(cnt)
                perimeter = cv2.arcLength(cnt, True)
                circularity = 0
                if perimeter > 0:
                    circularity = 4 * np.pi * (area / (perimeter**2))

                if circularity > CIRCULARITY_THRESHOLD:
                    void_count += 1
                    color_bgr = (0, 255, 0)
                    cv2.rectangle(frame_to_display, (x, y), (x+w, y+h), color_bgr, 2)
                else:
                    crack_count += 1
                    color_bgr = (0, 0, 255)
                    cv2.drawContours(frame_to_display, [cnt], -1, color_bgr, 2)

        try:
            frame_rgb_with_boxes = cv2.cvtColor(frame_to_display, cv2.COLOR_BGR2RGB)
            pil_img = Image.fromarray(frame_rgb_with_boxes)
            draw = ImageDraw.Draw(pil_img)

            text_void = f"보이드: {void_count} 개"
            text_crack = f"크랙: {crack_count} 개"
            
            if self.font_large:
                draw.text((20, 30), text_void, font=self.font_large, fill=(0, 255, 0))
                draw.text((20, 70), text_crack, font=self.font_large, fill=(255, 0, 0))

            return cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
        except Exception as e:
            print(f"PIL (mono) 렌더링 오류: {e}")
            return frame_to_display

    # --- [검사 로직 2] 컬러(현미경) 이미지용 ---
    def run_defect_detection_color(self, frame):
        """ 
        [컬러 전용] 
        - (작업 1) HSV 색상 공간을 사용해 '필러' 검출
        - (작업 2) Grayscale 임계값을 사용해 '보이드/크랙' 검출
        """
        
        PART_LOWER_H = 20
        PART_LOWER_S = 100
        PART_LOWER_V = 100
        PART_UPPER_H = 40
        PART_UPPER_S = 255
        PART_UPPER_V = 255
        MIN_PART_AREA = 500
        
        DEFECT_THRESHOLD = 60
        MIN_DEFECT_AREA = 20
        CIRCULARITY_THRESHOLD = 0.6
        
        try:
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        except Exception as e:
            print(f"이미지 변환 오류: {e}")
            return frame

        # [작업 1] 필러 검출 (HSV)
        lower_bound_part = np.array([PART_LOWER_H, PART_LOWER_S, PART_LOWER_V])
        upper_bound_part = np.array([PART_UPPER_H, PART_UPPER_S, PART_UPPER_V])
        part_mask = cv2.inRange(hsv, lower_bound_part, upper_bound_part)
        
        kernel_part = np.ones((5, 5), np.uint8)
        part_mask_opened = cv2.morphologyEx(part_mask, cv2.MORPH_OPEN, kernel_part, iterations=1)
        contours_part, _ = cv2.findContours(part_mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        part_count = 0
        for cnt in contours_part:
            if cv2.contourArea(cnt) > MIN_PART_AREA:
                part_count += 1
                x, y, w, h = cv2.boundingRect(cnt)
                cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2) # BGR (파랑)

        # [작업 2] 어두운 결함 검출 (Grayscale)
        _, defect_mask = cv2.threshold(gray, DEFECT_THRESHOLD, 255, cv2.THRESH_BINARY_INV)
        
        kernel_defect = np.ones((3, 3), np.uint8)
        defect_mask_opened = cv2.morphologyEx(defect_mask, cv2.MORPH_OPEN, kernel_defect, iterations=1)
        contours_defect, _ = cv2.findContours(defect_mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        void_count = 0
        crack_count = 0
        
        for cnt in contours_defect:
            area = cv2.contourArea(cnt)
            if area > MIN_DEFECT_AREA:
                perimeter = cv2.arcLength(cnt, True)
                circularity = 0
                if perimeter > 0:
                    circularity = 4 * np.pi * (area / (perimeter**2))

                if circularity > CIRCULARITY_THRESHOLD:
                    void_count += 1
                    cv2.drawContours(frame, [cnt], -1, (0, 255, 0), 2)
                else:
                    crack_count += 1
                    cv2.drawContours(frame, [cnt], -1, (0, 0, 255), 2)

        # [작업 3] PIL로 한글 텍스트 렌더링
        try:
            frame_rgb_with_boxes = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_img = Image.fromarray(frame_rgb_with_boxes)
            draw = ImageDraw.Draw(pil_img)

            text_part = f"필러(금): {part_count} 개"
            text_void = f"보이드: {void_count} 개"
            text_crack = f"크랙: {crack_count} 개"
            
            if self.font_small: # (font_small 사용)
                draw.text((20, 30), text_part, font=self.font_small, fill=(0, 0, 255)) # RGB (파랑)
                draw.text((20, 60), text_void, font=self.font_small, fill=(0, 255, 0)) # RGB (초록)
                draw.text((20, 90), text_crack, font=self.font_small, fill=(255, 0, 0)) # RGB (빨강)

            return cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

        except Exception as e:
            print(f"PIL (color) 렌더링 오류: {e}")
            return frame


class MicroscopeApp(QWidget):
    """ 메인 애플리케이션 GUI 위젯 """
    def __init__(self):
        super().__init__()
        
        self.thread = None
        self.current_pixmap = None # 현재 화면에 표시된 (그림이 포함된) 픽스맵
        
        # --- [신규] 돋보기/일시정지 버그 수정을 위해 '깨끗한 원본' 픽스맵 추가 ---
        self.clean_pixmap = None   # 스레드에서 막 받은 '깨끗한' 원본 픽스맵
        
        self.original_width = 0
        self.original_height = 0
        self.current_view_rect = None 
        self.is_zoom_mode = True 
        
        # --- [수정] 측정 로직 변경 ---
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = [] # 현재 그리는 점 (최대 2개)
        self.calibration_points = [] # 보정용 점 (최대 2개)
        self.measurement_lines = [] # (p1, p2, text) 튜플의 리스트
        self.px_per_mm_calibration = None # 줌 보정 변수
        # -----------------------------

        self.drag_start_point = None
        
        # --- [신규] 돋보기 ---
        self.loupe_label = None
        # -------------------

        self.setWindowTitle("시편 분석 프로그램(VER 1.4)") # (버전 업)
        self.init_ui()

    def init_ui(self):
        main_layout = QHBoxLayout()
        
        self.video_label = QLabel(self)
        self.video_label.setFixedSize(DISPLAY_WIDTH, DISPLAY_HEIGHT)
        self.video_label.setStyleSheet("background-color: #000; border: 1px solid #555;")
        self.video_label.setText("카메라 꺼짐")
        self.video_label.setAlignment(Qt.AlignCenter)
        # --- [핵심 수정] 돋보기가 작동하도록 마우스 추적 활성화 ---
        self.video_label.setMouseTracking(True)
        # ---------------------------------------------------
        main_layout.addWidget(self.video_label)
        
        self.rubber_band = QRubberBand(QRubberBand.Rectangle, self.video_label)
        
        # --- [신규] 돋보기 라벨 ---
        self.loupe_label = QLabel(self.video_label)
        self.loupe_label.setFixedSize(100, 100)
        self.loupe_label.setStyleSheet("border: 2px solid cyan; background-color: black;")
        self.loupe_label.setAlignment(Qt.AlignCenter)
        self.loupe_label.hide()
        # --------------------------

        # --- 오른쪽: 컨트롤 패널 ---
        control_layout = QVBoxLayout()
        
        # 1. 카메라 제어
        cam_group = QGroupBox("카메라 제어")
        cam_layout = QHBoxLayout()
        self.btn_toggle_cam = QPushButton("켜기/끄기 (Ctrl+O)")
        self.btn_toggle_cam.clicked.connect(self.toggle_camera)
        self.btn_toggle_cam.setShortcut("Ctrl+O")
        
        self.btn_pause = QPushButton("일시정지 (F1)")
        self.btn_pause.clicked.connect(self.pause_video)
        self.btn_pause.setShortcut("F1")
        self.btn_pause.setEnabled(False)
        
        cam_layout.addWidget(self.btn_toggle_cam)
        cam_layout.addWidget(self.btn_pause)
        cam_group.setLayout(cam_layout)
        control_layout.addWidget(cam_group)
        
        # [수정] 1.5. 밝기 제어
        brt_group = QGroupBox("밝기 제어")
        brt_layout = QVBoxLayout() 
        brt_buttons_layout = QHBoxLayout()
        
        self.btn_brt_down = QPushButton("밝기- (어둡게)")
        self.btn_brt_down.clicked.connect(self.decrease_brightness)
        self.btn_brt_down.setEnabled(False)
        
        self.btn_brt_up = QPushButton("밝기+ (밝게)")
        self.btn_brt_up.clicked.connect(self.increase_brightness)
        self.btn_brt_up.setEnabled(False)
        
        brt_buttons_layout.addWidget(self.btn_brt_down)
        brt_buttons_layout.addWidget(self.btn_brt_up)
        
        self.lbl_brightness_value = QLabel(f"현재 밝기: 0")
        self.lbl_brightness_value.setAlignment(Qt.AlignCenter)
        
        brt_layout.addLayout(brt_buttons_layout)
        brt_layout.addWidget(self.lbl_brightness_value)
        
        brt_group.setLayout(brt_layout)
        control_layout.addWidget(brt_group)
        
        # --- [신규] 1.6. 영상 필터 ---
        filter_group = QGroupBox("영상 필터")
        filter_layout = QVBoxLayout()
        
        self.chk_wb = QCheckBox("자동 화이트밸런스 (노란기 제거)")
        self.chk_wb.toggled.connect(self.toggle_white_balance)
        self.chk_wb.setEnabled(False)
        
        self.chk_denoise = QCheckBox("노이즈 제거 (Median Blur)")
        self.chk_denoise.toggled.connect(self.toggle_denoise)
        self.chk_denoise.setEnabled(False)
        
        self.chk_sharpen = QCheckBox("선명하게 (Sharpen)")
        self.chk_sharpen.toggled.connect(self.toggle_sharpen)
        self.chk_sharpen.setEnabled(False)
        
        filter_layout.addWidget(self.chk_wb)
        filter_layout.addWidget(self.chk_denoise)
        filter_layout.addWidget(self.chk_sharpen)
        
        filter_group.setLayout(filter_layout)
        control_layout.addWidget(filter_group)
        # --- 필터 끝 ---

        # 2. 줌 제어
        zoom_group = QGroupBox("줌 제어")
        zoom_layout = QHBoxLayout()
        self.btn_zoom_in = QPushButton("확대(Ctrl+↑)")
        self.btn_zoom_in.clicked.connect(self.zoom_in_button)
        self.btn_zoom_in.setShortcut("Ctrl+Up")
        
        self.btn_zoom_out = QPushButton("축소(Ctrl+↓)")
        self.btn_zoom_out.clicked.connect(self.zoom_out_button)
        self.btn_zoom_out.setShortcut("Ctrl+Down")
        
        self.btn_zoom_reset = QPushButton("줌 리셋(Ctrl+0)")
        self.btn_zoom_reset.clicked.connect(self.reset_zoom)
        self.btn_zoom_reset.setShortcut("Ctrl+0")
        
        zoom_layout.addWidget(self.btn_zoom_in)
        zoom_layout.addWidget(self.btn_zoom_out)
        zoom_layout.addWidget(self.btn_zoom_reset)
        zoom_group.setLayout(zoom_layout)
        control_layout.addWidget(zoom_group)

        # 3. 기능
        func_group = QGroupBox("기능")
        func_layout = QVBoxLayout()
        self.btn_capture = QPushButton("이미지 캡쳐 (Ctrl+S)")
        self.btn_capture.clicked.connect(self.capture_image)
        self.btn_capture.setShortcut("Ctrl+S")
        
        self.btn_classify = QPushButton("부품 검사 (Ctrl+D)")
        self.btn_classify.clicked.connect(self.toggle_classification)
        self.btn_classify.setShortcut("Ctrl+D")
        
        func_layout.addWidget(self.btn_capture)
        func_layout.addWidget(self.btn_classify)
        func_group.setLayout(func_layout)
        control_layout.addWidget(func_group)
        
        # 4. 거리 측정 / 줌 모드
        measure_group = QGroupBox("측정 / 마우스 모드(+Shift, 직교모드)")
        measure_layout = QVBoxLayout()

        self.btn_zoom_mode = QPushButton("현재 모드: 줌 (Ctrl+Z)")
        self.btn_zoom_mode.clicked.connect(self.toggle_zoom_mode)
        self.btn_zoom_mode.setShortcut("Ctrl+Z")
        self.btn_zoom_mode.setCheckable(True)
        self.btn_zoom_mode.setChecked(True) 
        
        self.btn_calibrate = QPushButton("기준 길이 설정 (Ctrl+R)")
        self.btn_calibrate.clicked.connect(self.start_calibration)
        self.btn_calibrate.setShortcut("Ctrl+R")
        
        self.btn_measure = QPushButton("거리 측정 시작 (Ctrl+M)")
        self.btn_measure.clicked.connect(self.start_measurement)
        self.btn_measure.setShortcut("Ctrl+M")
        
        # --- [신규] 측정 리셋 버튼 ---
        self.btn_reset_measure = QPushButton("측정 리셋")
        self.btn_reset_measure.clicked.connect(self.reset_measurement)
        # -----------------------------
        
        self.info_label = QLabel("상태: 대기 중")
        self.info_label.setStyleSheet("border: 1px solid #ccc; padding: 5px; min-height: 40px;")
        self.info_label.setWordWrap(True)

        self.update_mode_style()

        measure_layout.addWidget(self.btn_zoom_mode)
        measure_layout.addWidget(self.btn_calibrate)
        measure_layout.addWidget(self.btn_measure)
        measure_layout.addWidget(self.btn_reset_measure) # [신규] 리셋 버튼 추가
        measure_layout.addWidget(self.info_label)
        measure_group.setLayout(measure_layout)
        control_layout.addWidget(measure_group)

        control_layout.addStretch(1)

        control_widget = QWidget()
        control_widget.setLayout(control_layout)
        control_widget.setFixedWidth(300)
        main_layout.addWidget(control_widget)
        
        self.setLayout(main_layout)
        
        self.video_label.mousePressEvent = self.video_label_mouse_press
        self.video_label.mouseMoveEvent = self.video_label_mouse_move
        self.video_label.mouseReleaseEvent = self.video_label_mouse_release
        self.video_label.mouseLeaveEvent = self.video_label_mouse_leave
        self.loupe_label.raise_() 

    # --- 스레드 및 비디오 함수 ---
    
    def toggle_camera(self):
        if self.thread is None or not self.thread.isRunning():
            try:
                idx, ok = QInputDialog.getInt(self, "카메라 선택", "카메라 인덱스 번호:", 0, 0, 10)
                if not ok: return
                
                self.thread = VideoThread(camera_index=idx)
                self.thread.change_pixmap_signal.connect(self.update_image)
                self.thread.camera_started_signal.connect(self.on_camera_started)
                self.thread.brightness_update_signal.connect(self.update_brightness_label)
                self.thread.start()
                
                self.btn_toggle_cam.setText("카메라 끄기 (Ctrl+O)")
                self.btn_pause.setEnabled(True)
                self.btn_brt_down.setEnabled(True)
                self.btn_brt_up.setEnabled(True)
                self.chk_wb.setEnabled(True)
                self.chk_denoise.setEnabled(True)
                self.chk_sharpen.setEnabled(True)
                self.info_label.setText("카메라 켜짐")
            except Exception as e:
                QMessageBox.critical(self, "오류", f"카메라를 시작할 수 없습니다: {e}")
                self.thread = None
        else:
            self.thread.stop()
            self.thread = None
            self.video_label.clear()
            self.video_label.setText("카메라 꺼짐")
            
            self.btn_toggle_cam.setText("카메라 켜기 (Ctrl+O)")
            self.btn_pause.setEnabled(False)
            self.btn_brt_down.setEnabled(False)
            self.btn_brt_up.setEnabled(False)
            self.chk_wb.setChecked(False)
            self.chk_denoise.setChecked(False)
            self.chk_sharpen.setChecked(False)
            self.chk_wb.setEnabled(False)
            self.chk_denoise.setEnabled(False)
            self.chk_sharpen.setEnabled(False)
            self.info_label.setText("카메라 꺼짐")
            
            self.update_brightness_label(0) 
            self.btn_classify.setText("부품 검사 (Ctrl+D)")
            
            self.original_width = 0
            self.original_height = 0
            self.current_view_rect = None
            self.clean_pixmap = None # [신규]
            self.current_pixmap = None # [신규]

    def on_camera_started(self, width, height):
        self.original_width = width
        self.original_height = height
        self.current_view_rect = (0, 0, width, height)
        self.update_brightness_label(0) 
        print(f"GUI: 원본 해상도 {width}x{height} 확인됨.")

    def update_image(self, cv_img):
        """[스레드 연동] 스레드에서 받은 프레임을 화면에 업데이트"""
        rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        
        qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
        
        # [수정] 
        # 1. 스레드에서 받은 원본을 '깨끗한' 픽스맵으로 저장
        self.clean_pixmap = QPixmap.fromImage(qt_image)
        
        # 2. 현재 상태(점/선)를 깨끗한 픽스맵 위에 그림
        self.draw_measurement_lines()
        
        # 3. 최종 결과물(self.current_pixmap)을 화면에 표시
        self.video_label.setPixmap(self.current_pixmap)

    def update_brightness_label(self, value):
        self.lbl_brightness_value.setText(f"현재 밝기: {value}")

    def pause_video(self):
        if self.thread:
            is_paused = self.thread.toggle_pause()
            self.btn_pause.setText("계속 (F1)" if is_paused else "일시정지 (F1)")
            self.info_label.setText("일시정지됨" if is_paused else "카메라 켜짐")

    # --- 줌 함수 (일시정지 해제 로직 포함) ---
    def zoom_in_button(self):
        if self.current_view_rect is None: return
        x, y, w, h = self.current_view_rect
        new_w, new_h = w * 0.8, h * 0.8
        new_x, new_y = x + (w - new_w) / 2, y + (h - new_h) / 2
        self.apply_new_view_rect(new_x, new_y, new_w, new_h)
        self.resume_if_paused()

    def zoom_out_button(self):
        if self.current_view_rect is None: return
        x, y, w, h = self.current_view_rect
        new_w, new_h = w * 1.25, h * 1.25
        new_x, new_y = x - (new_w - w) / 2, y - (new_h - h) / 2
        self.apply_new_view_rect(new_x, new_y, new_w, new_h)
        self.resume_if_paused()

    def reset_zoom(self):
        if self.original_width > 0:
            self.apply_new_view_rect(0, 0, self.original_width, self.original_height)
            self.info_label.setText("줌 리셋됨")
            self.resume_if_paused()
            
    def apply_new_view_rect(self, x, y, w, h):
        if self.thread is None or self.original_width == 0:
            return

        x = max(0, x)
        y = max(0, y)
        w = min(self.original_width - x, w)
        h = min(self.original_height - y, h)
        if w < 2 or h < 2: return
        if w > self.original_width: w = self.original_width
        if h > self.original_height: h = self.original_height
        if x + w > self.original_width: x = self.original_width - w
        if y + h > self.original_height: y = self.original_height - h

        self.current_view_rect = (x, y, w, h)
        self.thread.set_view_rect(self.current_view_rect)
        
        zoom_ratio = self.get_current_zoom_ratio()
        self.info_label.setText(f"줌 배율: {zoom_ratio:.1f}x")

    def get_current_zoom_ratio(self):
        if self.original_width == 0 or self.current_view_rect is None or self.current_view_rect[2] == 0:
            return 1.0
        return self.original_width / self.current_view_rect[2]

    def resume_if_paused(self):
        if self.thread and self.thread._paused:
            self.pause_video()

    # --- 밝기/필터 제어 함수 ---
    def increase_brightness(self):
        if self.thread:
            self.thread.increase_brightness()

    def decrease_brightness(self):
        if self.thread:
            self.thread.decrease_brightness()

    def toggle_white_balance(self, state):
        if self.thread:
            self.thread.set_white_balance(state)
            self.info_label.setText(f"화이트밸런스: {'ON' if state else 'OFF'}")

    def toggle_denoise(self, state):
        if self.thread:
            self.thread.set_denoise(state)
            self.info_label.setText(f"노이즈 제거: {'ON' if state else 'OFF'}")

    def toggle_sharpen(self, state):
        if self.thread:
            self.thread.set_sharpen(state)
            self.info_label.setText(f"선명하게: {'ON' if state else 'OFF'}")
    
    # --- 기능 함수 ---
    def capture_image(self):
        if self.current_pixmap is None:
            QMessageBox.warning(self, "경고", "카메라가 켜져 있지 않습니다.")
            return
        fname, _ = QFileDialog.getSaveFileName(self, '이미지 저장', '', 
                                               'PNG 파일 (*.png);;JPEG 파일 (*.jpg)')
        if fname:
            if not self.current_pixmap.save(fname):
                QMessageBox.critical(self, "오류", "이미지 저장에 실패했습니다.")

    def toggle_classification(self):
        if self.thread is None:
            QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
            return

        current_mode = self.thread._classify_mode if hasattr(self.thread, '_classify_mode') else 'none'

        if current_mode != 'none':
            self.thread.set_classify_mode('none')
            self.info_label.setText("검사 기능 OFF")
            self.btn_classify.setText("부품 검사 (Ctrl+D)")
        else:
            items = ["1. 흑백 결함 검출 (보이드/크랙)", 
                     "2. 컬러 부품/결함 검출 (필러)"]
            
            item, ok = QInputDialog.getItem(self, "검사 모드 선택", 
                                            "적용할 검사 로직을 선택하세요:", items, 0, False)
            
            if ok and item:
                if item == items[0]: # 흑백
                    self.thread.set_classify_mode('mono_defect')
                    self.info_label.setText("검사 모드: 흑백 결함")
                else: # 컬러
                    self.thread.set_classify_mode('color_part')
                    self.info_label.setText("검사 모드: 컬러 부품")
                
                self.btn_classify.setText("검사 끄기 (Ctrl+D)")

    # --- 마우스 모드 토글 ---
    
    def toggle_zoom_mode(self):
        self.is_zoom_mode = self.btn_zoom_mode.isChecked()
        self.update_mode_style()
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = [] # [수정]
        self.calibration_points = [] # [수정]
        self.drag_start_point = None
        self.rubber_band.hide()
        self.loupe_label.hide()
        self.force_redraw() # [신규] 화면 갱신

    def update_mode_style(self):
        if self.is_zoom_mode:
            self.btn_zoom_mode.setText("현재 모드: 줌 (Ctrl+Z)")
            self.btn_zoom_mode.setStyleSheet("background-color: #e0e0ff; color: #000099;")
            self.info_label.setText("[줌 모드] 드래그하여 확대")
        else:
            self.btn_zoom_mode.setText("현재 모드: 측정 (Ctrl+Z)")
            self.btn_zoom_mode.setStyleSheet("background-color: #e0ffe0; color: #006600;")
            self.info_label.setText("[측정 모드] 클릭하여 측정/보정")

    # --- 마우스 이벤트 ---
    
    def video_label_mouse_press(self, event):
        if self.thread is None or event.button() != Qt.LeftButton:
            return
        if self.is_zoom_mode:
            self.drag_start_point = event.pos()
            self.rubber_band.setGeometry(QRect(self.drag_start_point, QSize()))
            self.rubber_band.show()
        elif self.is_calibrating or self.is_measuring:
            self.process_measurement_click(event)
            self.loupe_label.hide()

    def video_label_mouse_move(self, event):
        if self.is_zoom_mode and self.drag_start_point is not None:
            self.rubber_band.setGeometry(QRect(self.drag_start_point, event.pos()).normalized())
        
        # [신규] 측정/보정 모드에서 마우스 이동 시 돋보기 업데이트
        if not self.is_zoom_mode and (self.is_calibrating or self.is_measuring) and self.thread is not None:
            self.update_loupe(event.pos())

    def video_label_mouse_release(self, event):
        if self.thread is None or event.button() != Qt.LeftButton:
            return
        if self.is_zoom_mode:
            if self.drag_start_point is None: return
            drag_end_point = event.pos()
            self.rubber_band.hide()
            rect = QRect(self.drag_start_point, drag_end_point).normalized()
            self.drag_start_point = None
            if rect.width() < 10 or rect.height() < 10: return
            if self.current_view_rect is None: return

            curr_x, curr_y, curr_w, curr_h = self.current_view_rect
            x_ratio_start, y_ratio_start = rect.x() / DISPLAY_WIDTH, rect.y() / DISPLAY_HEIGHT
            w_ratio, h_ratio = rect.width() / DISPLAY_WIDTH, rect.height() / DISPLAY_HEIGHT
            new_x = curr_x + curr_w * x_ratio_start
            new_y = curr_y + curr_h * y_ratio_start
            new_w, new_h = curr_w * w_ratio, curr_h * h_ratio
            self.apply_new_view_rect(new_x, new_y, new_w, new_h)
            self.resume_if_paused()
            
    # [신규] 마우스가 라벨을 떠나면 돋보기 숨기기
    def video_label_mouse_leave(self, event):
        self.loupe_label.hide()
        
    # [신규] 돋보기 업데이트 함수
    def update_loupe(self, pos):
        # [수정] current_pixmap -> clean_pixmap
        if self.clean_pixmap is None:
            return
        
        loupe_size = 100 # 돋보기 라벨 크기
        # [수정] 40 -> 60 (확대율을 낮추고 화질 개선)
        grab_size = 60   # 원본에서 가져올 픽셀 영역 크기
        
        # 1. 원본 픽스맵에서 마우스 주변 영역 가져오기
        grab_rect = QRect(pos.x() - grab_size // 2, pos.y() - grab_size // 2, grab_size, grab_size)
        
        # 2. 픽셀화(FastTransformation)하여 확대
        # [수정] current_pixmap -> clean_pixmap
        # [수정] Qt.FastTransformation -> Qt.SmoothTransformation (깨짐 현상 개선)
        loupe_pixmap = self.clean_pixmap.copy(grab_rect).scaled(
            loupe_size, loupe_size, 
            Qt.KeepAspectRatio, 
            Qt.SmoothTransformation # 픽셀이 보이도록 NearestNeighbor 방식 사용
        )
        
        # 3. 십자선(Crosshair) 그리기
        painter = QPainter(loupe_pixmap)
        painter.setPen(QPen(Qt.cyan, 1))
        # (정중앙 픽셀을 정확히 가리키도록 1px 오프셋 조정)
        painter.drawLine(loupe_size // 2, 0, loupe_size // 2, loupe_size) # 수직
        painter.drawLine(0, loupe_size // 2, loupe_size, loupe_size // 2) # 수평
        painter.end()
        
        # 4. 돋보기 라벨에 적용 및 위치 이동
        self.loupe_label.setPixmap(loupe_pixmap)
        
        # [수정] 마우스 커서 옆으로 이동 (오프셋 +15px)
        # 화면 가장자리를 벗어나지 않도록 경계 처리
        new_x = pos.x() + 15
        new_y = pos.y() + 15
        
        if new_x + loupe_size > DISPLAY_WIDTH:
            new_x = pos.x() - loupe_size - 15 # 커서 왼쪽으로
        if new_y + loupe_size > DISPLAY_HEIGHT:
            new_y = pos.y() - loupe_size - 15 # 커서 위쪽으로
            
        self.loupe_label.move(new_x, new_y) 
        self.loupe_label.show()
            
    # --- [수정] 거리 측정 함수 (로직 변경) ---
    
    def start_calibration(self):
        if self.thread is None: return QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
        if self.is_zoom_mode: self.toggle_zoom_mode()
        
        self.is_calibrating = True
        self.is_measuring = False
        self.calibration_points = [] # [수정] 보정용 포인트 리스트 초기화
        self.current_points = []
        # (기존 측정 라인(measurement_lines)은 지우지 않음)
        
        self.info_label.setText(f"[보정 모드 @ {self.get_current_zoom_ratio():.1f}x]\n"
                            "기준 길이의 두 끝점을 클릭하세요. (Shift: 직교)")
        self.force_redraw()

    def start_measurement(self):
        if self.thread is None: return QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
        if self.px_per_mm_calibration is None: return QMessageBox.warning(self, "경고", "먼저 [기준 길이 설정]을 완료해야 합니다.")
        if self.is_zoom_mode: self.toggle_zoom_mode()
            
        self.is_calibrating = False
        self.is_measuring = True
        self.current_points = [] # [수정] 현재 그릴 포인트 리스트 초기화
        
        self.info_label.setText("[측정 모드] 측정할 두 점을 클릭하세요.")
        self.force_redraw()
        
    # [신규] 측정 리셋 함수
    def reset_measurement(self):
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = []
        self.calibration_points = []
        self.measurement_lines = []
        self.info_label.setText("측정 리셋됨.")
        self.force_redraw()

    def process_measurement_click(self, event):
        pos = event.pos()
        is_shift_pressed = event.modifiers() & Qt.ShiftModifier
        
        # [수정] 보정/측정 로직 분리
        target_points = None
        if self.is_calibrating:
            target_points = self.calibration_points
        elif self.is_measuring:
            target_points = self.current_points
        else:
            return # 측정 모드가 아니면 무시

        # [수정] (self.is_calibrating or self.is_measuring)
        if (self.is_calibrating or self.is_measuring) and is_shift_pressed and len(target_points) == 1:
            p1 = target_points[0]
            dx, dy = abs(pos.x() - p1.x()), abs(pos.y() - p1.y())
            new_pos = QPoint(pos)
            
            mode_text = "[보정 모드]" if self.is_calibrating else "[측정 모드]"

            if dx > dy:
                new_pos.setY(p1.y())
                self.info_label.setText(f"{mode_text} Shift: 수평 직교 모드 적용됨.")
            else:
                new_pos.setX(p1.x())
                self.info_label.setText(f"{mode_text} Shift: 수직 직교 모드 적용됨.")
            target_points.append(new_pos)
        else:
            target_points.append(pos)
        
        # [수정] 로직 변경
        if len(target_points) == 2:
            self.process_measurement_calculation()
        elif len(target_points) > 2:
            # 리셋
            if self.is_measuring:
                self.current_points = [pos]
                self.info_label.setText("[측정 모드] 다시 시작. 첫 번째 점 클릭됨.")
            elif self.is_calibrating:
                self.calibration_points = [pos]
                self.info_label.setText("[보정 모드] 다시 시작. 첫 번째 점 클릭됨.")
            
        self.force_redraw()
            
    def process_measurement_calculation(self):
        # [수정] 보정/측정 로직 분리
        if self.is_calibrating:
            if len(self.calibration_points) != 2: return
            p1, p2 = self.calibration_points
            pixel_distance = ((p1.x() - p2.x())**2 + (p1.y() - p2.y())**2)**0.5
            
            real_dist, ok = QInputDialog.getDouble(self, "기준 길이 입력", 
                                               f"선택한 픽셀 거리: {pixel_distance:.2f} px\n\n이 픽셀의 실제 길이(mm)를 입력하세요:", 
                                               1.0, 0.001, 10000, 3)
            
            if ok and real_dist > 0:
                base_view_rect_w = self.current_view_rect[2]
                px_per_mm = pixel_distance / real_dist
                self.px_per_mm_calibration = (base_view_rect_w, px_per_mm)
                
                base_zoom = self.original_width / base_view_rect_w
                self.info_label.setText(f"[보정 완료 @ {base_zoom:.1f}x]\n"
                                    f"1mm = {px_per_mm:.2f} px (기준 배율)\n[측정 모드]로 자동 전환합니다.")
                self.is_calibrating = False
                self.is_measuring = True
                self.calibration_points = [] # [수정] 보정선 제거
                self.current_points = []
            else:
                self.info_label.setText("[보정 취소] 다시 두 점을 클릭하세요.")
                self.calibration_points = []
                
        elif self.is_measuring and self.px_per_mm_calibration is not None:
            if len(self.current_points) != 2: return
            p1, p2 = self.current_points
            pixel_distance = ((p1.x() - p2.x())**2 + (p1.y() - p2.y())**2)**0.5

            base_view_w, base_px_per_mm = self.px_per_mm_calibration
            current_view_w = self.current_view_rect[2]
            
            zoom_correction = base_view_w / current_view_w
            current_px_per_mm = base_px_per_mm * zoom_correction
            real_distance = pixel_distance / current_px_per_mm
            
            base_zoom = self.original_width / base_view_w
            current_zoom = self.get_current_zoom_ratio()
            
            # [신규] 계산된 거리값을 텍스트로 저장
            distance_text = f"{real_distance:.3f} mm"
            # [신규] 완료된 선 목록에 추가
            self.measurement_lines.append( (p1, p2, distance_text) )
            
            self.info_label.setText(f"[측정 완료 @ {current_zoom:.1f}x]\n"
                                f"픽셀: {pixel_distance:.2f} px\n"
                                f"측정 거리: {distance_text} (보정됨)\n"
                                f"(보정 기준 배율: {base_zoom:.1f}x)")
            
            self.current_points = [] # [수정] 다음 측정을 위해 현재 포인트 리셋

    # [신규] 화면 강제 갱신용 헬퍼 함수
    def force_redraw(self):
        """현재 clean_pixmap 기준으로 화면을 강제로 다시 그립니다."""
        if self.clean_pixmap:
            self.draw_measurement_lines()
            self.video_label.setPixmap(self.current_pixmap)

    def draw_measurement_lines(self):
        # [수정] 아키텍처 변경
        
        # 1. 깨끗한 원본(clean_pixmap)이 없으면 아무것도 하지 않음
        if self.clean_pixmap is None:
            self.current_pixmap = None
            return
            
        # 2. 깨끗한 원본을 복사하여 그림 그리기 시작
        pixmap_copy = self.clean_pixmap.copy()
        painter = QPainter(pixmap_copy)
        
        # 3. 그릴 점/선이 없으면, 깨끗한 원본을 current_pixmap으로 설정하고 종료
        if not self.calibration_points and not self.current_points and not self.measurement_lines:
            self.current_pixmap = pixmap_copy
            painter.end()
            return

        # [수정] 폰트 설정
        font = QFont('Malgun Gothic', 10, QFont.Bold) if 'Malgun Gothic' in QFont().family() else QFont()
        font.setPointSize(10)
        font.setBold(True)
        painter.setFont(font)
        
        # --- (이하는 점/선이 있을 경우에만 실행됨) ---
        
        # 4. (신규) 완료된 모든 측정 선(초록색) 그리기
        painter.setPen(QPen(Qt.green, 2, Qt.SolidLine))
        for p1, p2, text in self.measurement_lines:
            painter.drawEllipse(p1, 3, 3)
            painter.drawEllipse(p2, 3, 3)
            painter.drawLine(p1, p2)
            
            # 측정값 텍스트 그리기
            mid_point = QPoint((p1.x() + p2.x()) // 2, (p1.y() + p2.y()) // 2)
            painter.setPen(QPen(Qt.yellow))
            painter.drawText(mid_point.x() + 5, mid_point.y() - 5, text)

        # 5. (신규) 현재 그리고 있는 보정 선(청록색) 그리기
        if self.is_calibrating and self.calibration_points:
            painter.setPen(QPen(Qt.cyan, 2, Qt.SolidLine))
            p1 = self.calibration_points[0]
            painter.drawEllipse(p1, 3, 3)
            if len(self.calibration_points) == 2:
                p2 = self.calibration_points[1]
                painter.drawEllipse(p2, 3, 3)
                painter.drawLine(p1, p2)

        # 6. (신규) 현재 그리고 있는 측정 선(초록색) 그리기
        if self.is_measuring and self.current_points:
            painter.setPen(QPen(Qt.green, 2, Qt.SolidLine))
            p1 = self.current_points[0]
            painter.drawEllipse(p1, 3, 3)
            if len(self.current_points) == 2: # (이 상태는 거의 없어야 하지만, 안전장치)
                p2 = self.current_points[1]
                painter.drawEllipse(p2, 3, 3)
                painter.drawLine(p1, p2)

        painter.end()
        # [수정] self.current_pixmap을 최종 결과물로 교체
        self.current_pixmap = pixmap_copy
            
    def closeEvent(self, event):
        if self.thread:
            self.thread.stop()
        event.accept()

    def keyPressEvent(self, event):
        if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_O:
            self.toggle_camera()
            event.accept()
            return

        if event.key() == Qt.Key_F1:
            self.pause_video()
            event.accept()
            return
        
        # [수정] 누락되었던 Ctrl+0 (줌 리셋) 단축키 추가
        if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_0:
            self.reset_zoom()
            event.accept()
            return

        super().keyPressEvent(event)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    # [핵심 1] QApplication에 전체 한글 폰트 적용
    korean_font_name = 'Malgun Gothic, NanumGothic, Arial Unicode MS'
    font = QFont(korean_font_name, 9)
    app.setFont(font)

    ex = MicroscopeApp()
    ex.show()
    sys.exit(app.exec_())
