import sys
import cv2
import numpy as np
import time
import os
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                             QPushButton, QLabel, QFileDialog, QInputDialog, 
                             QMessageBox, QGroupBox, QRubberBand, QCheckBox)
from PyQt5.QtGui import QImage, QPixmap, QPainter, QPen, QFont 
from PyQt5.QtCore import QThread, pyqtSignal, Qt, QSize, QRect, QPoint
try:
    from PIL import Image, ImageDraw, ImageFont
except ImportError:
    print("오류: Pillow 라이브러리가 필요합니다. 'pip install Pillow'로 설치해주세요.")
    sys.exit()


# --- 한글 폰트 경로 설정 ---
DEFAULT_FONT_PATH = "HMKMRHD.TTF"

def get_korean_font(size=20):
    """시스템 경로에서 한글 폰트(TTF)를 로드합니다. (PIL용)"""
    font_path = DEFAULT_FONT_PATH
    
    if not os.path.exists(font_path):
        print(f"경고: 지정된 폰트 '{font_path}'를 찾을 수 없습니다. 대체 경로 탐색을 시작합니다.")
        if sys.platform == "win32":
            font_path = "C:/Windows/Fonts/malgun.ttf"
            if not os.path.exists(font_path):
                 font_path = "C:/Windows/Fonts/gulim.ttc"
        elif sys.platform == "darwin":
            font_path = "/System/Library/Fonts/Supplemental/AppleSDGothicNeo.ttf"
        elif sys.platform == "linux":
            font_path = "/usr/share/fonts/truetype/nanum/NanumGothicBold.ttf"
            if not os.path.exists(font_path):
                font_path = "/usr/share/fonts/truetype/nanum/NanumGothic.ttf"
    
    try:
        print(f"PIL 폰트 로드 시도: {font_path}")
        return ImageFont.truetype(font_path, size)
    except IOError:
        print(f"경고: 한글 폰트 '{font_path}'를 찾을 수 없습니다. PIL 기본 폰트를 사용합니다.")
        try:
            return ImageFont.load_default()
        except Exception:
            return None

# 상수: GUI에 표시될 영상의 기본 크기
DISPLAY_WIDTH = 800
DISPLAY_HEIGHT = 600

class VideoThread(QThread):
    """
    OpenCV 카메라 처리를 담당하는 백그라운드 스레드
    """
    change_pixmap_signal = pyqtSignal(np.ndarray)
    camera_started_signal = pyqtSignal(int, int) 
    brightness_update_signal = pyqtSignal(int)

    def __init__(self, camera_index=0):
        super().__init__()
        self.camera_index = camera_index
        self._running = True
        self._paused = False
        
        self._classify_mode = 'none'
        
        self.view_rect = None 
        self.original_width = 0
        self.original_height = 0
        
        self._brightness = 0
        self._brightness_delta = 0
        
        self._apply_wb = False
        self._apply_denoise = False
        self._apply_sharpen = False
        
        self.kernel_sharpen = np.array([[-1,-1,-1],
                                        [-1, 9,-1],
                                        [-1,-1,-1]])
        
        self.last_good_frame = None
        
        self.font_large = get_korean_font(size=24)
        self.font_small = get_korean_font(size=16)

    def run(self):
        """스레드 실행: 카메라 캡쳐 및 프레임 처리 루프 (일시정지 수정됨)"""
        cap = cv2.VideoCapture(self.camera_index)
        
        if not cap.isOpened():
            print(f"Error: Camera index {self.camera_index}를 열 수 없습니다.")
            return

        self.original_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.original_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        if self.view_rect is None:
            self.view_rect = (0, 0, self.original_width, self.original_height)
        
        print(f"카메라 원본 해상도: {self.original_width}x{self.original_height}")
        self.camera_started_signal.emit(self.original_width, self.original_height)

        while self._running:
            if not self._paused:
                ret, original_frame = cap.read() 
                if ret:
                    self.last_good_frame = original_frame.copy()
            
            if self.last_good_frame is not None:
                current_frame = self.last_good_frame.copy()

                # --- [1] 소프트웨어 밝기 조절 로직 ---
                if self._brightness_delta != 0:
                    self._brightness += (self._brightness_delta * 10)
                    self._brightness = max(-100, min(100, self._brightness))
                    print(f"소프트웨어 밝기 변경: {self._brightness}")
                    self._brightness_delta = 0
                    self.brightness_update_signal.emit(self._brightness)
                
                if self._brightness != 0:
                    adjusted_frame = cv2.convertScaleAbs(current_frame, alpha=1.0, beta=self._brightness)
                else:
                    adjusted_frame = current_frame
                
                # --- 영상 필터 적용 ---
                if self._apply_wb:
                    adjusted_frame = self.correct_white_balance(adjusted_frame)
                if self._apply_denoise:
                    adjusted_frame = cv2.medianBlur(adjusted_frame, 5)
                if self._apply_sharpen:
                    adjusted_frame = cv2.filter2D(adjusted_frame, -1, self.kernel_sharpen)

                # --- [2] 줌(Crop) 로직 ---
                try:
                    x, y, w, h = self.view_rect
                    x, y, w, h = int(x), int(y), int(w), int(h)
                    cv_img = adjusted_frame[y:y + h, x:x + w]
                except Exception as e:
                    print(f"Crop Error: {e}, view_rect: {self.view_rect}")
                    cv_img = adjusted_frame

                # --- [3] 리사이즈 ---
                display_frame = cv2.resize(cv_img, (DISPLAY_WIDTH, DISPLAY_HEIGHT), 
                                           interpolation=cv2.INTER_LINEAR)
                
                # --- [4] 결함 분석 ---
                if self._classify_mode == 'mono_defect':
                    display_frame = self.run_defect_detection_mono(display_frame)
                elif self._classify_mode == 'color_part':
                    display_frame = self.run_defect_detection_color(display_frame)

                # --- [5] GUI 전송 ---
                self.change_pixmap_signal.emit(display_frame.copy())
            
            time.sleep(0.01)

        cap.release()

    def stop(self):
        self._running = False
        self.wait()

    def toggle_pause(self):
        self._paused = not self._paused
        return self._paused
        
    def increase_brightness(self):
        self._brightness_delta += 1

    def decrease_brightness(self):
        self._brightness_delta -= 1
    
    def set_view_rect(self, rect):
        self.view_rect = rect

    def set_classify_mode(self, mode):
        self._classify_mode = mode
            
    def set_white_balance(self, state):
        self._apply_wb = state
    
    def set_denoise(self, state):
        self._apply_denoise = state
        
    def set_sharpen(self, state):
        self._apply_sharpen = state

    def correct_white_balance(self, frame):
        try:
            avg_b = np.mean(frame[:, :, 0])
            avg_g = np.mean(frame[:, :, 1])
            avg_r = np.mean(frame[:, :, 2])
            avg_all = (avg_b + avg_g + avg_r) / 3
            scale_b = avg_all / avg_b
            scale_g = avg_all / avg_g
            scale_r = avg_all / avg_r
            
            balanced_frame = frame.copy()
            balanced_frame[:, :, 0] = np.clip(frame[:, :, 0] * scale_b, 0, 255).astype(np.uint8)
            balanced_frame[:, :, 1] = np.clip(frame[:, :, 1] * scale_g, 0, 255).astype(np.uint8)
            balanced_frame[:, :, 2] = np.clip(frame[:, :, 2] * scale_r, 0, 255).astype(np.uint8)
            
            return balanced_frame
        except Exception as e:
            print(f"White Balance Error: {e}")
            return frame
            
    # --- [검사 로직 1] 흑백(SEM) 이미지용 (흑백 뷰 + CLAHE 분석) ---
    def run_defect_detection_mono(self, frame):
        DEFECT_THRESHOLD = 50 
        MIN_AREA = 20
        CIRCULARITY_THRESHOLD = 0.6 
        
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        gray_analyzed = clahe.apply(gray)
        frame_to_display = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
        
        _, defect_mask = cv2.threshold(gray_analyzed, DEFECT_THRESHOLD, 255, cv2.THRESH_BINARY_INV)
        
        kernel = np.ones((3, 3), np.uint8)
        mask_opened = cv2.morphologyEx(defect_mask, cv2.MORPH_OPEN, kernel, iterations=1)
        contours, _ = cv2.findContours(mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        void_count = 0
        crack_count = 0
        
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > MIN_AREA:
                x, y, w, h = cv2.boundingRect(cnt)
                perimeter = cv2.arcLength(cnt, True)
                circularity = 0
                if perimeter > 0:
                    circularity = 4 * np.pi * (area / (perimeter**2))

                if circularity > CIRCULARITY_THRESHOLD:
                    void_count += 1
                    color_bgr = (0, 255, 0)
                    cv2.rectangle(frame_to_display, (x, y), (x+w, y+h), color_bgr, 2)
                else:
                    crack_count += 1
                    color_bgr = (0, 0, 255)
                    cv2.drawContours(frame_to_display, [cnt], -1, color_bgr, 2)
        try:
            frame_rgb_with_boxes = cv2.cvtColor(frame_to_display, cv2.COLOR_BGR2RGB)
            pil_img = Image.fromarray(frame_rgb_with_boxes)
            draw = ImageDraw.Draw(pil_img)
            text_void = f"보이드: {void_count} 개"
            text_crack = f"크랙: {crack_count} 개"
            
            if self.font_large:
                draw.text((20, 30), text_void, font=self.font_large, fill=(0, 255, 0))
                draw.text((20, 70), text_crack, font=self.font_large, fill=(255, 0, 0))

            return cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
        except Exception as e:
            print(f"PIL (mono) 렌더링 오류: {e}")
            return frame_to_display

    # --- [검사 로직 2] 컬러(현미경) 이미지용 ---
    def run_defect_detection_color(self, frame):
        PART_LOWER_H = 20
        PART_LOWER_S = 100
        PART_LOWER_V = 100
        PART_UPPER_H = 40
        PART_UPPER_S = 255
        PART_UPPER_V = 255
        MIN_PART_AREA = 500
        DEFECT_THRESHOLD = 60
        MIN_DEFECT_AREA = 20
        CIRCULARITY_THRESHOLD = 0.6
        
        try:
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        except Exception as e:
            print(f"이미지 변환 오류: {e}")
            return frame

        # [작업 1] 필러 검출 (HSV)
        lower_bound_part = np.array([PART_LOWER_H, PART_LOWER_S, PART_LOWER_V])
        upper_bound_part = np.array([PART_UPPER_H, PART_UPPER_S, PART_UPPER_V])
        part_mask = cv2.inRange(hsv, lower_bound_part, upper_bound_part)
        
        kernel_part = np.ones((5, 5), np.uint8)
        part_mask_opened = cv2.morphologyEx(part_mask, cv2.MORPH_OPEN, kernel_part, iterations=1)
        contours_part, _ = cv2.findContours(part_mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        part_count = 0
        for cnt in contours_part:
            if cv2.contourArea(cnt) > MIN_PART_AREA:
                part_count += 1
                x, y, w, h = cv2.boundingRect(cnt)
                cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)

        # [작업 2] 어두운 결함 검출 (Grayscale)
        _, defect_mask = cv2.threshold(gray, DEFECT_THRESHOLD, 255, cv2.THRESH_BINARY_INV)
        
        kernel_defect = np.ones((3, 3), np.uint8)
        defect_mask_opened = cv2.morphologyEx(defect_mask, cv2.MORPH_OPEN, kernel_defect, iterations=1)
        contours_defect, _ = cv2.findContours(defect_mask_opened, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        void_count = 0
        crack_count = 0
        
        for cnt in contours_defect:
            area = cv2.contourArea(cnt)
            if area > MIN_DEFECT_AREA:
                perimeter = cv2.arcLength(cnt, True)
                circularity = 0
                if perimeter > 0:
                    circularity = 4 * np.pi * (area / (perimeter**2))

                if circularity > CIRCULARITY_THRESHOLD:
                    void_count += 1
                    cv2.drawContours(frame, [cnt], -1, (0, 255, 0), 2)
                else:
                    crack_count += 1
                    cv2.drawContours(frame, [cnt], -1, (0, 0, 255), 2)

        # [작업 3] PIL로 한글 텍스트 렌더링
        try:
            frame_rgb_with_boxes = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_img = Image.fromarray(frame_rgb_with_boxes)
            draw = ImageDraw.Draw(pil_img)

            text_part = f"필러(금): {part_count} 개"
            text_void = f"보이드: {void_count} 개"
            text_crack = f"크랙: {crack_count} 개"
            
            if self.font_small:
                draw.text((20, 30), text_part, font=self.font_small, fill=(0, 0, 255))
                draw.text((20, 60), text_void, font=self.font_small, fill=(0, 255, 0))
                draw.text((20, 90), text_crack, font=self.font_small, fill=(255, 0, 0))

            return cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

        except Exception as e:
            print(f"PIL (color) 렌더링 오류: {e}")
            return frame


class MicroscopeApp(QWidget):
    """ 메인 애플리케이션 GUI 위젯 """
    def __init__(self):
        super().__init__()
        
        self.thread = None
        self.current_pixmap = None 
        self.clean_pixmap = None   # 스레드에서 막 받은 '깨끗한' 원본 픽스맵
        
        self.original_width = 0
        self.original_height = 0
        self.current_view_rect = None 
        self.is_zoom_mode = True 
        
        # --- [수정] 측정 로직 변경 ---
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = [] # 현재 그리는 점 (최대 2개)
        self.calibration_points = [] # 보정용 점 (최대 2개)
        self.measurement_lines = [] # (p1, p2, text) 튜플의 리스트
        self.px_per_mm_calibration = None
        # -----------------------------

        self.drag_start_point = None
        self.loupe_label = None

        self.setWindowTitle("시편 분석 프로그램(VER 1.5)") # (버전 업)
        self.init_ui()

    def init_ui(self):
        main_layout = QHBoxLayout()
        
        self.video_label = QLabel(self)
        self.video_label.setFixedSize(DISPLAY_WIDTH, DISPLAY_HEIGHT)
        self.video_label.setStyleSheet("background-color: #000; border: 1px solid #555;")
        self.video_label.setText("카메라 꺼짐")
        self.video_label.setAlignment(Qt.AlignCenter)
        # --- [핵심 수정] 돋보기를 위한 마우스 추적 활성화 ---
        self.video_label.setMouseTracking(True)
        main_layout.addWidget(self.video_label)
        
        self.rubber_band = QRubberBand(QRubberBand.Rectangle, self.video_label)
        
        self.loupe_label = QLabel(self.video_label)
        self.loupe_label.setFixedSize(100, 100)
        self.loupe_label.setStyleSheet("border: 2px solid cyan; background-color: black;")
        self.loupe_label.setAlignment(Qt.AlignCenter)
        self.loupe_label.hide()

        # --- 오른쪽: 컨트롤 패널 ---
        control_layout = QVBoxLayout()
        
        # 1. 카메라 제어
        cam_group = QGroupBox("카메라 제어")
        cam_layout = QHBoxLayout()
        self.btn_toggle_cam = QPushButton("켜기/끄기 (Ctrl+O)")
        self.btn_toggle_cam.clicked.connect(self.toggle_camera)
        # self.btn_toggle_cam.setShortcut("Ctrl+O") # [제거] keyPressEvent로 이동
        
        self.btn_pause = QPushButton("일시정지 (F1)")
        self.btn_pause.clicked.connect(self.pause_video)
        # self.btn_pause.setShortcut("F1") # [제거] keyPressEvent로 이동
        self.btn_pause.setEnabled(False)
        
        cam_layout.addWidget(self.btn_toggle_cam)
        cam_layout.addWidget(self.btn_pause)
        cam_group.setLayout(cam_layout)
        control_layout.addWidget(cam_group)
        
        # 1.5. 밝기 제어
        brt_group = QGroupBox("밝기 제어")
        brt_layout = QVBoxLayout() 
        brt_buttons_layout = QHBoxLayout()
        
        self.btn_brt_down = QPushButton("밝기- (어둡게)")
        self.btn_brt_down.clicked.connect(self.decrease_brightness)
        self.btn_brt_down.setEnabled(False)
        
        self.btn_brt_up = QPushButton("밝기+ (밝게)")
        self.btn_brt_up.clicked.connect(self.increase_brightness)
        self.btn_brt_up.setEnabled(False)
        
        brt_buttons_layout.addWidget(self.btn_brt_down)
        brt_buttons_layout.addWidget(self.btn_brt_up)
        
        self.lbl_brightness_value = QLabel(f"현재 밝기: 0")
        self.lbl_brightness_value.setAlignment(Qt.AlignCenter)
        
        brt_layout.addLayout(brt_buttons_layout)
        brt_layout.addWidget(self.lbl_brightness_value)
        
        brt_group.setLayout(brt_layout)
        control_layout.addWidget(brt_group)
        
        # 1.6. 영상 필터
        filter_group = QGroupBox("영상 필터")
        filter_layout = QVBoxLayout()
        
        self.chk_wb = QCheckBox("자동 화이트밸런스 (노란기 제거)")
        self.chk_wb.toggled.connect(self.toggle_white_balance)
        self.chk_wb.setEnabled(False)
        
        self.chk_denoise = QCheckBox("노이즈 제거 (Median Blur)")
        self.chk_denoise.toggled.connect(self.toggle_denoise)
        self.chk_denoise.setEnabled(False)
        
        self.chk_sharpen = QCheckBox("선명하게 (Sharpen)")
        self.chk_sharpen.toggled.connect(self.toggle_sharpen)
        self.chk_sharpen.setEnabled(False)
        
        filter_layout.addWidget(self.chk_wb)
        filter_layout.addWidget(self.chk_denoise)
        filter_layout.addWidget(self.chk_sharpen)
        
        filter_group.setLayout(filter_layout)
        control_layout.addWidget(filter_group)

        # 2. 줌 제어
        zoom_group = QGroupBox("줌 제어")
        zoom_layout = QHBoxLayout()
        self.btn_zoom_in = QPushButton("확대(Ctrl+I)")
        self.btn_zoom_in.clicked.connect(self.zoom_in_button)
        # self.btn_zoom_in.setShortcut("Ctrl+8") # [제거]
        
        self.btn_zoom_out = QPushButton("축소(Ctrl+K)")
        self.btn_zoom_out.clicked.connect(self.zoom_out_button)
        # self.btn_zoom_out.setShortcut("Ctrl+2") # [제거]
        
        self.btn_zoom_reset = QPushButton("줌 리셋(Ctrl+J)")
        self.btn_zoom_reset.clicked.connect(self.reset_zoom)
        # self.btn_zoom_reset.setShortcut("Ctrl+5") # [제거]
        
        zoom_layout.addWidget(self.btn_zoom_in)
        zoom_layout.addWidget(self.btn_zoom_out)
        zoom_layout.addWidget(self.btn_zoom_reset)
        zoom_group.setLayout(zoom_layout)
        control_layout.addWidget(zoom_group)

        # 3. 기능
        func_group = QGroupBox("기능")
        func_layout = QVBoxLayout()
        self.btn_capture = QPushButton("이미지 캡쳐 (Ctrl+S)")
        self.btn_capture.clicked.connect(self.capture_image)
        # self.btn_capture.setShortcut("Ctrl+S") # [제거]
        
        self.btn_classify = QPushButton("부품 검사 (Ctrl+D)")
        self.btn_classify.clicked.connect(self.toggle_classification)
        # self.btn_classify.setShortcut("Ctrl+D") # [제거]
        
        func_layout.addWidget(self.btn_capture)
        func_layout.addWidget(self.btn_classify)
        func_group.setLayout(func_layout)
        control_layout.addWidget(func_group)
        
        # 4. 거리 측정 / 줌 모드
        measure_group = QGroupBox("측정 / 마우스 모드")
        measure_layout = QVBoxLayout()

        self.btn_zoom_mode = QPushButton("현재 모드: 줌 (Ctrl+Z)")
        self.btn_zoom_mode.clicked.connect(self.toggle_zoom_mode)
        # self.btn_zoom_mode.setShortcut("Ctrl+Z") # [제거]
        self.btn_zoom_mode.setCheckable(True)
        self.btn_zoom_mode.setChecked(True) 
        
        self.btn_calibrate = QPushButton("기준 길이 설정 (Ctrl+R)")
        self.btn_calibrate.clicked.connect(self.start_calibration)
        # self.btn_calibrate.setShortcut("Ctrl+R") # [제거]
        
        self.btn_measure = QPushButton("거리 측정 시작 (Ctrl+M)")
        self.btn_measure.clicked.connect(self.start_measurement)
        # self.btn_measure.setShortcut("Ctrl+M") # [제거]
        
        self.btn_reset_measure = QPushButton("측정 리셋")
        self.btn_reset_measure.clicked.connect(self.reset_measurement)
        
        self.info_label = QLabel("상태: 대기 중")
        self.info_label.setStyleSheet("border: 1px solid #ccc; padding: 5px; min-height: 40px;")
        self.info_label.setWordWrap(True)

        self.update_mode_style()

        measure_layout.addWidget(self.btn_zoom_mode)
        measure_layout.addWidget(self.btn_calibrate)
        measure_layout.addWidget(self.btn_measure)
        measure_layout.addWidget(self.btn_reset_measure)
        measure_layout.addWidget(self.info_label)
        measure_group.setLayout(measure_layout)
        control_layout.addWidget(measure_group)

        control_layout.addStretch(1)

        control_widget = QWidget()
        control_widget.setLayout(control_layout)
        control_widget.setFixedWidth(300)
        main_layout.addWidget(control_widget)
        
        self.setLayout(main_layout)
        
        self.video_label.mousePressEvent = self.video_label_mouse_press
        self.video_label.mouseMoveEvent = self.video_label_mouse_move
        self.video_label.mouseReleaseEvent = self.video_label_mouse_release
        self.video_label.mouseLeaveEvent = self.video_label_mouse_leave
        self.loupe_label.raise_() 

    # --- 스레드 및 비디오 함수 ---
    
    def toggle_camera(self):
        if self.thread is None or not self.thread.isRunning():
            try:
                idx, ok = QInputDialog.getInt(self, "카메라 선택", "카메라 인덱스 번호:", 0, 0, 10)
                if not ok: return
                
                self.thread = VideoThread(camera_index=idx)
                self.thread.change_pixmap_signal.connect(self.update_image)
                self.thread.camera_started_signal.connect(self.on_camera_started)
                self.thread.brightness_update_signal.connect(self.update_brightness_label)
                self.thread.start()
                
                self.btn_toggle_cam.setText("카메라 끄기 (Ctrl+O)")
                self.btn_pause.setEnabled(True)
                self.btn_brt_down.setEnabled(True)
                self.btn_brt_up.setEnabled(True)
                self.chk_wb.setEnabled(True)
                self.chk_denoise.setEnabled(True)
                self.chk_sharpen.setEnabled(True)
                self.info_label.setText("카메라 켜짐")
            except Exception as e:
                QMessageBox.critical(self, "오류", f"카메라를 시작할 수 없습니다: {e}")
                self.thread = None
        else:
            self.thread.stop()
            self.thread = None
            self.video_label.clear()
            self.video_label.setText("카메라 꺼짐")
            
            self.btn_toggle_cam.setText("카메라 켜기 (Ctrl+O)")
            self.btn_pause.setEnabled(False)
            self.btn_brt_down.setEnabled(False)
            self.btn_brt_up.setEnabled(False)
            self.chk_wb.setChecked(False)
            self.chk_denoise.setChecked(False)
            self.chk_sharpen.setChecked(False)
            self.chk_wb.setEnabled(False)
            self.chk_denoise.setEnabled(False)
            self.chk_sharpen.setEnabled(False)
            self.info_label.setText("카메라 꺼짐")
            
            self.update_brightness_label(0) 
            self.btn_classify.setText("부품 검사 (Ctrl+D)")
            
            self.original_width = 0
            self.original_height = 0
            self.current_view_rect = None
            self.clean_pixmap = None
            self.current_pixmap = None

    def on_camera_started(self, width, height):
        self.original_width = width
        self.original_height = height
        self.current_view_rect = (0, 0, width, height)
        self.update_brightness_label(0) 
        print(f"GUI: 원본 해상도 {width}x{height} 확인됨.")

    def update_image(self, cv_img):
        """[스레드 연동] 스레드에서 받은 프레임을 화면에 업데이트"""
        rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
        self.clean_pixmap = QPixmap.fromImage(qt_image)
        self.draw_measurement_lines()
        self.video_label.setPixmap(self.current_pixmap)

    def update_brightness_label(self, value):
        self.lbl_brightness_value.setText(f"현재 밝기: {value}")

    def pause_video(self):
        if self.thread:
            is_paused = self.thread.toggle_pause()
            self.btn_pause.setText("계속 (F1)" if is_paused else "일시정지 (F1)")
            self.info_label.setText("일시정지됨" if is_paused else "카메라 켜짐")

    # --- 줌 함수 (일시정지 해제 로직 포함) ---
    def zoom_in_button(self):
        if self.current_view_rect is None: return
        x, y, w, h = self.current_view_rect
        new_w, new_h = w * 0.8, h * 0.8
        new_x, new_y = x + (w - new_w) / 2, y + (h - new_h) / 2
        self.apply_new_view_rect(new_x, new_y, new_w, new_h)
        self.resume_if_paused()

    def zoom_out_button(self):
        if self.current_view_rect is None: return
        x, y, w, h = self.current_view_rect
        new_w, new_h = w * 1.25, h * 1.25
        new_x, new_y = x - (new_w - w) / 2, y - (new_h - h) / 2
        self.apply_new_view_rect(new_x, new_y, new_w, new_h)
        self.resume_if_paused()

    def reset_zoom(self):
        if self.original_width > 0:
            self.apply_new_view_rect(0, 0, self.original_width, self.original_height)
            self.info_label.setText("줌 리셋됨")
            self.resume_if_paused()
            
    def apply_new_view_rect(self, x, y, w, h):
        if self.thread is None or self.original_width == 0:
            return

        x = max(0, x)
        y = max(0, y)
        w = min(self.original_width - x, w)
        h = min(self.original_height - y, h)
        if w < 2 or h < 2: return
        if w > self.original_width: w = self.original_width
        if h > self.original_height: h = self.original_height
        if x + w > self.original_width: x = self.original_width - w
        if y + h > self.original_height: y = self.original_height - h

        self.current_view_rect = (x, y, w, h)
        self.thread.set_view_rect(self.current_view_rect)
        
        zoom_ratio = self.get_current_zoom_ratio()
        self.info_label.setText(f"줌 배율: {zoom_ratio:.1f}x")

    def get_current_zoom_ratio(self):
        if self.original_width == 0 or self.current_view_rect is None or self.current_view_rect[2] == 0:
            return 1.0
        return self.original_width / self.current_view_rect[2]

    def resume_if_paused(self):
        if self.thread and self.thread._paused:
            self.pause_video()

    # --- 밝기/필터 제어 함수 ---
    def increase_brightness(self):
        if self.thread:
            self.thread.increase_brightness()

    def decrease_brightness(self):
        if self.thread:
            self.thread.decrease_brightness()

    def toggle_white_balance(self, state):
        if self.thread:
            self.thread.set_white_balance(state)
            self.info_label.setText(f"화이트밸런스: {'ON' if state else 'OFF'}")

    def toggle_denoise(self, state):
        if self.thread:
            self.thread.set_denoise(state)
            self.info_label.setText(f"노이즈 제거: {'ON' if state else 'OFF'}")

    def toggle_sharpen(self, state):
        if self.thread:
            self.thread.set_sharpen(state)
            self.info_label.setText(f"선명하게: {'ON' if state else 'OFF'}")
    
    # --- 기능 함수 ---
    def capture_image(self):
        if self.current_pixmap is None:
            QMessageBox.warning(self, "경고", "카메라가 켜져 있지 않습니다.")
            return
        fname, _ = QFileDialog.getSaveFileName(self, '이미지 저장', '', 
                                               'PNG 파일 (*.png);;JPEG 파일 (*.jpg)')
        if fname:
            if not self.current_pixmap.save(fname):
                QMessageBox.critical(self, "오류", "이미지 저장에 실패했습니다.")

    def toggle_classification(self):
        if self.thread is None:
            QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
            return

        current_mode = self.thread._classify_mode if hasattr(self.thread, '_classify_mode') else 'none'

        if current_mode != 'none':
            self.thread.set_classify_mode('none')
            self.info_label.setText("검사 기능 OFF")
            self.btn_classify.setText("부품 검사 (Ctrl+D)")
        else:
            items = ["1. 흑백 결함 검출 (보이드/크랙)", 
                     "2. 컬러 부품/결함 검출 (필러)"]
            
            item, ok = QInputDialog.getItem(self, "검사 모드 선택", 
                                            "적용할 검사 로직을 선택하세요:", items, 0, False)
            
            if ok and item:
                if item == items[0]: # 흑백
                    self.thread.set_classify_mode('mono_defect')
                    self.info_label.setText("검사 모드: 흑백 결함")
                else: # 컬러
                    self.thread.set_classify_mode('color_part')
                    self.info_label.setText("검사 모드: 컬러 부품")
                
                self.btn_classify.setText("검사 끄기 (Ctrl+D)")

    # --- 마우스 모드 토글 ---
    
    def toggle_zoom_mode(self):
        self.is_zoom_mode = self.btn_zoom_mode.isChecked()
        self.update_mode_style()
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = []
        self.calibration_points = []
        self.drag_start_point = None
        self.rubber_band.hide()
        self.loupe_label.hide()
        self.force_redraw()

    def update_mode_style(self):
        if self.is_zoom_mode:
            self.btn_zoom_mode.setText("현재 모드: 줌 (Ctrl+Z)")
            self.btn_zoom_mode.setStyleSheet("background-color: #e0e0ff; color: #000099;")
            self.info_label.setText("[줌 모드] 드래그하여 확대")
        else:
            self.btn_zoom_mode.setText("현재 모드: 측정 (Ctrl+Z)")
            self.btn_zoom_mode.setStyleSheet("background-color: #e0ffe0; color: #006600;")
            self.info_label.setText("[측정 모드] 클릭하여 측정/보정")

    # --- 마우스 이벤트 ---
    
    def video_label_mouse_press(self, event):
        if self.thread is None or event.button() != Qt.LeftButton:
            return
        if self.is_zoom_mode:
            self.drag_start_point = event.pos()
            self.rubber_band.setGeometry(QRect(self.drag_start_point, QSize()))
            self.rubber_band.show()
        elif self.is_calibrating or self.is_measuring:
            self.process_measurement_click(event)
            self.loupe_label.hide()

    def video_label_mouse_move(self, event):
        if self.is_zoom_mode and self.drag_start_point is not None:
            self.rubber_band.setGeometry(QRect(self.drag_start_point, event.pos()).normalized())
        
        if not self.is_zoom_mode and (self.is_calibrating or self.is_measuring) and self.thread is not None:
            self.update_loupe(event.pos())

    def video_label_mouse_release(self, event):
        if self.thread is None or event.button() != Qt.LeftButton:
            return
        if self.is_zoom_mode:
            if self.drag_start_point is None: return
            drag_end_point = event.pos()
            self.rubber_band.hide()
            rect = QRect(self.drag_start_point, drag_end_point).normalized()
            self.drag_start_point = None
            if rect.width() < 10 or rect.height() < 10: return
            if self.current_view_rect is None: return

            curr_x, curr_y, curr_w, curr_h = self.current_view_rect
            x_ratio_start, y_ratio_start = rect.x() / DISPLAY_WIDTH, rect.y() / DISPLAY_HEIGHT
            w_ratio, h_ratio = rect.width() / DISPLAY_WIDTH, rect.height() / DISPLAY_HEIGHT
            new_x = curr_x + curr_w * x_ratio_start
            new_y = curr_y + curr_h * y_ratio_start
            new_w, new_h = curr_w * w_ratio, curr_h * h_ratio
            self.apply_new_view_rect(new_x, new_y, new_w, new_h)
            self.resume_if_paused()
            
    def video_label_mouse_leave(self, event):
        self.loupe_label.hide()
        
    def update_loupe(self, pos):
        if self.clean_pixmap is None:
            return
        
        loupe_size = 100
        grab_size = 60 # [수정] 40 -> 60
        
        grab_rect = QRect(pos.x() - grab_size // 2, pos.y() - grab_size // 2, grab_size, grab_size)
        
        # [수정] Qt.SmoothTransformation
        loupe_pixmap = self.clean_pixmap.copy(grab_rect).scaled(
            loupe_size, loupe_size, 
            Qt.KeepAspectRatio, 
            Qt.SmoothTransformation
        )
        
        painter = QPainter(loupe_pixmap)
        painter.setPen(QPen(Qt.cyan, 1))
        painter.drawLine(loupe_size // 2, 0, loupe_size // 2, loupe_size)
        painter.drawLine(0, loupe_size // 2, loupe_size, loupe_size // 2)
        painter.end()
        
        self.loupe_label.setPixmap(loupe_pixmap)
        
        # [수정] 마우스 커서 옆으로 이동
        new_x = pos.x() + 15
        new_y = pos.y() + 15
        
        if new_x + loupe_size > DISPLAY_WIDTH:
            new_x = pos.x() - loupe_size - 15
        if new_y + loupe_size > DISPLAY_HEIGHT:
            new_y = pos.y() - loupe_size - 15
            
        self.loupe_label.move(new_x, new_y) 
        self.loupe_label.show()
            
    # --- 거리 측정 함수 (줌 보정 로직 포함) ---
    
    def start_calibration(self):
        if self.thread is None: return QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
        if self.is_zoom_mode: self.toggle_zoom_mode()
        
        self.is_calibrating = True
        self.is_measuring = False
        self.calibration_points = []
        self.current_points = []
        
        self.info_label.setText(f"[보정 모드 @ {self.get_current_zoom_ratio():.1f}x]\n"
                            "기준 길이의 두 끝점을 클릭하세요. (Shift: 직교)")
        self.force_redraw()

    def start_measurement(self):
        if self.thread is None: return QMessageBox.warning(self, "경고", "카메라를 먼저 켜주세요.")
        if self.px_per_mm_calibration is None: return QMessageBox.warning(self, "경고", "먼저 [기준 길이 설정]을 완료해야 합니다.")
        if self.is_zoom_mode: self.toggle_zoom_mode()
            
        self.is_calibrating = False
        self.is_measuring = True
        self.current_points = []
        
        self.info_label.setText("[측정 모드] 측정할 두 점을 클릭하세요.")
        self.force_redraw()
        
    def reset_measurement(self):
        self.is_calibrating = False
        self.is_measuring = False
        self.current_points = []
        self.calibration_points = []
        self.measurement_lines = []
        self.info_label.setText("측정 리셋됨.")
        self.force_redraw()

    def process_measurement_click(self, event):
        pos = event.pos()
        is_shift_pressed = event.modifiers() & Qt.ShiftModifier
        
        target_points = None
        if self.is_calibrating:
            target_points = self.calibration_points
        elif self.is_measuring:
            target_points = self.current_points
        else:
            return

        if (self.is_calibrating or self.is_measuring) and is_shift_pressed and len(target_points) == 1:
            p1 = target_points[0]
            dx, dy = abs(pos.x() - p1.x()), abs(pos.y() - p1.y())
            new_pos = QPoint(pos)
            
            mode_text = "[보정 모드]" if self.is_calibrating else "[측정 모드]"

            if dx > dy:
                new_pos.setY(p1.y())
                self.info_label.setText(f"{mode_text} Shift: 수평 직교 모드 적용됨.")
            else:
                new_pos.setX(p1.x())
                self.info_label.setText(f"{mode_text} Shift: 수직 직교 모드 적용됨.")
            target_points.append(new_pos)
        else:
            target_points.append(pos)
        
        if len(target_points) == 2:
            self.process_measurement_calculation()
        elif len(target_points) > 2:
            if self.is_measuring:
                self.current_points = [pos]
                self.info_label.setText("[측정 모드] 다시 시작. 첫 번째 점 클릭됨.")
            elif self.is_calibrating:
                self.calibration_points = [pos]
                self.info_label.setText("[보정 모드] 다시 시작. 첫 번째 점 클릭됨.")
            
        self.force_redraw()
            
    def process_measurement_calculation(self):
        if self.is_calibrating:
            if len(self.calibration_points) != 2: return
            p1, p2 = self.calibration_points
            pixel_distance = ((p1.x() - p2.x())**2 + (p1.y() - p2.y())**2)**0.5
            
            real_dist, ok = QInputDialog.getDouble(self, "기준 길이 입력", 
                                               f"선택한 픽셀 거리: {pixel_distance:.2f} px\n\n이 픽셀의 실제 길이(mm)를 입력하세요:", 
                                               1.0, 0.001, 10000, 3)
            
            if ok and real_dist > 0:
                base_view_rect_w = self.current_view_rect[2]
                px_per_mm = pixel_distance / real_dist
                self.px_per_mm_calibration = (base_view_rect_w, px_per_mm)
                
                base_zoom = self.original_width / base_view_rect_w
                self.info_label.setText(f"[보정 완료 @ {base_zoom:.1f}x]\n"
                                    f"1mm = {px_per_mm:.2f} px (기준 배율)\n[측정 모드]로 자동 전환합니다.")
                self.is_calibrating = False
                self.is_measuring = True
                self.calibration_points = [] # [수정] 보정선 제거
                self.current_points = []
            else:
                self.info_label.setText("[보정 취소] 다시 두 점을 클릭하세요.")
                self.calibration_points = []
                
        elif self.is_measuring and self.px_per_mm_calibration is not None:
            if len(self.current_points) != 2: return
            p1, p2 = self.current_points
            pixel_distance = ((p1.x() - p2.x())**2 + (p1.y() - p2.y())**2)**0.5

            base_view_w, base_px_per_mm = self.px_per_mm_calibration
            current_view_w = self.current_view_rect[2]
            
            zoom_correction = base_view_w / current_view_w
            current_px_per_mm = base_px_per_mm * zoom_correction
            real_distance = pixel_distance / current_px_per_mm
            
            base_zoom = self.original_width / base_view_w
            current_zoom = self.get_current_zoom_ratio()
            
            distance_text = f"{real_distance:.3f} mm"
            self.measurement_lines.append( (p1, p2, distance_text) )
            
            self.info_label.setText(f"[측정 완료 @ {current_zoom:.1f}x]\n"
                                f"픽셀: {pixel_distance:.2f} px\n"
                                f"측정 거리: {distance_text} (보정됨)\n"
                                f"(보정 기준 배율: {base_zoom:.1f}x)")
            
            self.current_points = [] # 다음 측정을 위해 현재 포인트 리셋

    def force_redraw(self):
        """현재 clean_pixmap 기준으로 화면을 강제로 다시 그립니다."""
        if self.clean_pixmap:
            self.draw_measurement_lines()
            self.video_label.setPixmap(self.current_pixmap)

    def draw_measurement_lines(self):
        if self.clean_pixmap is None:
            self.current_pixmap = None
            return
            
        pixmap_copy = self.clean_pixmap.copy()
        
        if not self.calibration_points and not self.current_points and not self.measurement_lines:
            self.current_pixmap = pixmap_copy
            return

        painter = QPainter(pixmap_copy)
        
        font = QFont('Malgun Gothic', 10, QFont.Bold) if 'Malgun Gothic' in QFont().family() else QFont()
        font.setPointSize(10)
        font.setBold(True)
        painter.setFont(font)
        
        # 4. (신규) 완료된 모든 측정 선(초록색) 그리기
        painter.setPen(QPen(Qt.green, 2, Qt.SolidLine))
        for p1, p2, text in self.measurement_lines:
            painter.drawEllipse(p1, 3, 3)
            painter.drawEllipse(p2, 3, 3)
            painter.drawLine(p1, p2)
            
            mid_point = QPoint((p1.x() + p2.x()) // 2, (p1.y() + p2.y()) // 2)
            painter.setPen(QPen(Qt.yellow))
            painter.drawText(mid_point.x() + 5, mid_point.y() - 5, text)

        # 5. (신규) 현재 그리고 있는 보정 선(청록색) 그리기
        if self.is_calibrating and self.calibration_points:
            painter.setPen(QPen(Qt.cyan, 2, Qt.SolidLine))
            p1 = self.calibration_points[0]
            painter.drawEllipse(p1, 3, 3)
            if len(self.calibration_points) == 2:
                p2 = self.calibration_points[1]
                painter.drawEllipse(p2, 3, 3)
                painter.drawLine(p1, p2)

        # 6. (신규) 현재 그리고 있는 측정 선(초록색) 그리기
        if self.is_measuring and self.current_points:
            painter.setPen(QPen(Qt.green, 2, Qt.SolidLine))
            p1 = self.current_points[0]
            painter.drawEllipse(p1, 3, 3)
            if len(self.current_points) == 2:
                p2 = self.current_points[1]
                painter.drawEllipse(p2, 3, 3)
                painter.drawLine(p1, p2)

        painter.end()
        self.current_pixmap = pixmap_copy
            
    def closeEvent(self, event):
        if self.thread:
            self.thread.stop()
        event.accept()

    # --- [핵심 수정] 모든 단축키를 keyPressEvent로 통합 ---
    def keyPressEvent(self, event):
        
        # 1. Non-Ctrl modifiers (like F1)
        if event.key() == Qt.Key_F1:
            self.pause_video()
            event.accept()
            return

        # 2. Check for Ctrl modifier
        if event.modifiers() == Qt.ControlModifier:
            key = event.key()
            
            if key == Qt.Key_O:
                self.toggle_camera()
            elif key == Qt.Key_J:
                self.reset_zoom()
            elif key == Qt.Key_S:
                self.capture_image()
            elif key == Qt.Key_D:
                self.toggle_classification()
            elif key == Qt.Key_Z:
                # toggle_zoom_mode는 체크박스 상태를 반전시키므로 .click() 호출
                self.btn_zoom_mode.click() 
            elif key == Qt.Key_R:
                self.start_calibration()
            elif key == Qt.Key_M:
                self.start_measurement()
            elif key == Qt.Key_I:    # Ctrl+I
                self.zoom_in_button()
            elif key == Qt.Key_K:  # Ctrl+K
                self.zoom_out_button()
            else:
                super().keyPressEvent(event) # Pass unhandled keys
                return
            
            event.accept() # Mark as handled
            return

        super().keyPressEvent(event) # Pass all other key events

if __name__ == '__main__':
    app = QApplication(sys.argv)
    
    # [핵심 1] QApplication에 전체 한글 폰트 적용
    korean_font_name = 'Malgun Gothic, NanumGothic, Arial Unicode MS'
    font = QFont(korean_font_name, 9)
    app.setFont(font)

    ex = MicroscopeApp()
    ex.show()
    sys.exit(app.exec_())
